### 题目
https://leetcode.com/problems/path-sum-iii/

### 分类
* 二叉树
    * 后序遍历

### 答案 (当前解决方案的时间复杂度是O(n^2))
```
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

public List<List<Integer>> postOrder(TreeNode root, int targetSum) {
    List<List<Integer>> allSums = new ArrayList<>();
    List<Integer> sums = new ArrayList<>();
    // fSums list contains finished sums, which will not be calculated in the top TreeNodes
    List<Integer> fSums = new ArrayList<>();
    if (root != null) {
        List<List<Integer>> allLeftSums = postOrder(root.left, targetSum);
        List<Integer> leftSums = allLeftSums.get(0);
        List<Integer> leftFSums = allLeftSums.get(1);
        List<List<Integer>> allRightSums = postOrder(root.right, targetSum);
        List<Integer> rightSums = allRightSums.get(0);
        List<Integer> rightFSums = allRightSums.get(1);
        fSums.addAll(leftFSums);
        fSums.addAll(rightFSums);
        for (int i = 0; i < leftSums.size(); i++) {
            if (leftSums.get(i) == targetSum) {
                fSums.add(leftSums.get(i));
            }
            sums.add(leftSums.get(i) + root.val);
        }
        for (int i = 0; i < rightSums.size(); i++) {
            if (rightSums.get(i) == targetSum) {
                fSums.add(rightSums.get(i));
            }
            sums.add(rightSums.get(i) + root.val);
        }
        sums.add(root.val);
    }
    allSums.add(sums);
    allSums.add(fSums);
    return allSums;
}

public int pathSum(TreeNode root, int targetSum) {
    List<List<Integer>> allSums = postOrder(root, targetSum);
    List<Integer> sums = allSums.get(0);
    List<Integer> fSums = allSums.get(1);
    int count = 0;
    for (int i = 0; i < sums.size(); i++) {
        if (sums.get(i) == targetSum) {
            count++;
        }
    }
    return count + fSums.size();
}
```

### 复杂度
* 时间复杂度：O(n^2) [二叉树后序遍历O(n)，每次遍历都要计算一次sum](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Binary-Tree)
* 空间复杂度：O(logn)，最坏情况是O(n) 二叉树后序遍历](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Binary-Search-Tree)
