### 题目
https://leetcode.com/problems/palindrome-linked-list/

### 分类
* 链表

### 思路1
* 链表

### 答案
```
public boolean isPalindrome(ListNode head) {
    
    if (head.next == null) {
        return true;
    }
    
    List<ListNode> nodes = new ArrayList<>();
    
    while (head != null) {
        nodes.add(head);
        head = head.next;
    }
    
    int mid = nodes.size() / 2;
    
    // 反转链表的前半部分
    for (int i = mid - 1; i > 0; i--) {
        nodes.get(i).next = nodes.get(i - 1);
    }
    nodes.get(0).next = null;
    
    // 链表前半部分
    ListNode list1 = nodes.get(mid - 1);
    // 链表后半部分
    ListNode list2 = nodes.size() % 2 == 0 ? nodes.get(mid) : nodes.get(mid + 1);
    
    while (list2 != null) {
        if (list1.val != list2.val) {
            return false;
        }
        list1 = list1.next;
        list2 = list2.next;
    }
    
    return true;
}
```

### 复杂度
* 时间复杂度：O(n)
* 空间复杂度：O(1)
