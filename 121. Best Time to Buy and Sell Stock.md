### 题目
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

### 分类
* 序列型动态规划
* 贪心

### 题目特点
* 求最大最小值：从一次股票买卖中获得的**最大**利润 [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)
* 一维数组
    * 一般创建n + 1个元素
    * int[] f = new int[n + 1];
    * 求前i个元素f[i]，即i = 0为初始条件无元素，即i = 1为前一个元素，...，i == n为前n个元素
        * 需要注意题目给的数组和f的关系
        * 即：题目给的数组中前i个元素的下标为0 ... i - 1，第i + 1个元素的下标为i；而f[i] = 前i个元素
        * 例：题目给的数组中前9个元素的下标为0 ... 8，第10个元素的下标9；而f[9] = 前9个元素
    * 最终答案返回f[n]
* 二维数组
    * 一般创建m + 1行n + 1列
    * int[][] f = new int[m + 1][n + 1];
    * 求前ij个元素的，即i = 0和j = 0为初始条件无元素，可能i = 0整行和j = 0整列都需要初始化，i == m和j = n为前m行n列个元素
        * 需要注意题目给的数组和f的关系
        * 即：题目给的数组中前8行9列个元素的下标为0, 0 ... i - 1, j - 1，第i + 1, j + 1个元素的下标为i, j；而f[i][j] = 前i行j列个元素
        * 例：题目给的数组中前8行9列个元素的下标为0, 0 ... 7, 8，第10个元素的下标9；而f[8][9] = 前8行9列个元素
    * 最终答案返回f[m][n]

### 思路1
* 序列型动态规划

0. 输入prices代表一只股票每天的价格，n为总天数prices.length

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f[x] = **前x天中一次股票买卖中获得的最大利润**

#### 最后一步
* **前n - 1天中一次股票买卖中获得的最大利润**
* 原问题是**前n天中一次股票买卖中获得的最大利润**
* 我们将原问题转化成了一个子问题，而且规模更小：n - 1

2. 转移方程
* f[x] = max{f[x - 1], prices[x - 1] - y}, y = min{prices[x - 1], y}
    * f[x] = 前x天中一次股票买卖中获得的**最大**利润
    * y = 前x天中的**最低**值

3. 初始条件和边界情况
* 初始条件
    * f[0] = 0
    * y = prices[0]
* 边界情况
    * 无

4. 计算顺序
* **前x天中一次股票买卖中获得的最大利润**：f[x] = max{f[x - 1], prices[x - 1] - y}, y = min{prices[x - 1], y}
* 初始条件：f[0] = 0，y = prices[0]
* 然后计算f[1]，f[2]，...，f[n]，这里按照从小到大的顺序，由于每个结果都存在了数组中，就能解决重复计算
* 当我们计算到f[x]时，f[1]，f[2]，...，f[x - 1]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 每一步只要观察f[x - 1]和y的值
    * 总时间复杂度 = O(n)

#### 其它要点
* 本题求从**多**次股票买卖中获得的**最大**利润
* 目的是求**股票所有上升段的和**
    * 简化思想：只要是上升段都进行买卖
    * 代码和动态规划一样，但不是动态规划的思想

### 答案
```
public int maxProfit(int[] prices) {
    int n = prices.length;
    if (n == 0) {
        return 0;
    }
    int[] f = new int[n + 1];
    // 初始条件
    f[0] = 0;
    int lowest = prices[0];
    // 每一步只要观察f[x - 1]的值
    for (int i = 1; i <= n; i++) {
        f[i] = Math.max(f[i - 1], prices[i - 1] - lowest);
        lowest = Math.min(lowest, prices[i - 1]);
    }
    return f[n];
}
```

### 复杂度
* 时间复杂度：O(n)
* 空间复杂度：O(n)，由于f[x]只与f[x - 1]相关，可优化到O(1)
