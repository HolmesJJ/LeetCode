## 二分查找

使用条件
* 排序数组(30-40%是二分)
* 当面试官要求你找一个比O(n) 更小的时间复杂度算法的时候(99%)
* 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足(100%)
* 找到一个最大/最小的值使得某个条件被满足(90%)

### 非递归版
```
// Corner Case 处理
if (nums == null || nums.length == 0) {
    return -1;
}

public int binarySearch(int[] nums, int target) {
      
    int low = 0;
    int high = nums.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        // | ---------- | --target-- |
        if (nums[mid] < target) {
            low = mid + 1;
        }
        // | --target-- | ---------- |
        else {
            high = mid - 1;
        }
    }
    return low;
}

// 找不到位置
int pos = binarySearch(nums, target);
if (pos == -1 || nums[pos] < target) {
    return -1;
}
```

### 递归版
```
// Corner Case 处理
if (nums == null || nums.length == 0) {
    return -1;
}

public int binarySearch(int[] nums, int target, int low, int high) {
    if (low > high) {
        return low;
    }
    int mid = low + (high - low) / 2;
    // | ---------- | --target-- |
    if (nums[mid] < target) {
        return binarySearch(nums, target, mid + 1, high);
    }
     // | --target-- | ---------- |
    else {
        return binarySearch(nums, target, low, mid - 1);
    }
}

// 找不到位置
int pos = binarySearch(nums, target, 0, nums.length - 1);
if (pos == -1 || nums[pos] < target) {
    return -1;
}
```

### 复杂度
* 时间复杂度：O(logn)
* 空间复杂度：O(1)
