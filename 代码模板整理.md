## 二分查找

### 使用条件
* 排序数组(30-40%是二分)
* 当面试官要求你找一个比O(n) 更小的时间复杂度算法的时候(99%)
* 找到数组中的一个分割位置，使得左半部分满足某个条件，右半部分不满足(100%)
* 找到一个最大/最小的值使得某个条件被满足(90%)

### 典型例题
* 矩阵二分查找 [74. Search a 2D Matrix](74.%20Search%20a%202D%20Matrix.md)
* 二叉树与二分查找的结合 [222. Count Complete Tree Nodes](222.%20Count%20Complete%20Tree%20Nodes.md)

### 非递归版
```
// Corner Case 处理
if (nums == null || nums.length == 0) {
    return -1;
}

// 若找不到target，则返回比target大一点的值的位置
// 若target值重复，则始终返回第一个target的位置；若要返回最后一个target的位置，则需要修改为nums[mid] <= target
public int binarySearch(int[] nums, int target) {
    int low = 0;
    int high = nums.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        // | ---------- | --target-- |
        if (nums[mid] < target) {
            low = mid + 1;
        }
        // | --target-- | ---------- |
        else {
            high = mid - 1;
        }
    }
    return low;
}

// 找不到target
int pos = binarySearch(nums, target);
if (pos == nums.length || nums[pos] > target) {
    return -1;
}
```

### 递归版
```
// Corner Case 处理
if (nums == null || nums.length == 0) {
    return -1;
}

// 若找不到target，则返回比target大一点的值的位置
// 若target值重复，则始终返回第一个target的位置；若要返回最后一个target的位置，则需要修改为nums[mid] <= target
public int binarySearch(int[] nums, int target, int low, int high) {
    if (low > high) {
        return low;
    }
    int mid = low + (high - low) / 2;
    // | ---------- | --target-- |
    if (nums[mid] < target) {
        return binarySearch(nums, target, mid + 1, high);
    }
     // | --target-- | ---------- |
    else {
        return binarySearch(nums, target, low, mid - 1);
    }
}

// 找不到target
int pos = binarySearch(nums, target, 0, nums.length - 1);
if (pos == nums.length || nums[pos] > target) {
    return -1;
}
```

### 复杂度
* 时间复杂度：O(logn)
* 空间复杂度：O(1)

## 转换

### `List<Integer>` to `int[]`
```
int[] array = list.stream().mapToInt(i -> i).toArray();
// OR
int[] array = list.stream().mapToInt(Integer::intValue).toArray();
```

## `HashMap`

### 遍历
```
for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
    int key = entry.getKey();
    int value = entry.getValue();
}
```

### 记录元素出现的次数
```
for (int i = 0; i < nums.length; i++) {
    map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
}
```

## `Math`

```
Math.abs(x)     // 绝对值
Math.pow(x, y)  // x^y，返回double
Math.max(x, y)  // 返回较大值
Math.min(x, y)  // 返回较小值
```

## ToDo
* `TreeMap`和`HashMap`的遍历和排序
