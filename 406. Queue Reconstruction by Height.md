### 题目
https://leetcode.com/problems/can-place-flowers/

### 分类
* 贪心

### 思路1
* 为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第k个位置可能会变成第k+1个位置
    * 身高h降序，个数k值升序，然后将某个学生插入队列的第k个位置中

```
例：[[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]
排序后：[[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]

处理过程
[[7, 0]]
[[7, 0], [7, 1]]
[[7, 0], [6, 1], [7, 1]]
[[5, 0], [7, 0], [6, 1], [7, 1]]
[[5, 0], [7, 0], [5, 2], [6, 1], [7, 1]]
[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]
```

### 答案
```java
public int[][] reconstructQueue(int[][] people) {
    
    // 按照身高来排序，若身高相同，按照前面的人数排序
    Arrays.sort(people, (o1, o2) -> {
        // 注意这里不能直接o1[0] - o2[0]或o1[1] - o2[1]，否则会导致整型溢出
        // 例：[[-2147483646,-2147483645],[2147483646,2147483647]]
        if (o1[0] > o2[0]) {
            return - 1;
        } else if (o1[0] == o2[0]) {
            if (o1[1] < o2[1]) {
                return - 1;
            } else if (o1[1] == o2[1]) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    });
    
    List<int[]> results = new ArrayList<>();
    for (int i = 0; i < people.length; i++) {
        // 当前要插入的位置已存在时，会自动将当前位置及之后的元素全部后移进行插入
        results.add(people[i][1], people[i]);
    }
    return results.toArray(new int[results.size()][2]);
}
```

### 复杂度
* 时间复杂度：O(n^2)
* 空间复杂度：O(n)
