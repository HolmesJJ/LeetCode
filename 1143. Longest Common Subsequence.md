### 题目
https://leetcode.com/problems/longest-common-subsequence/

### 分类
* 双序列型动态规划

### 题目特点
求最大最小值：字符串A和B的**最长**公共子序列（字符串）的长度 [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)

### 思路1
0. 输入两个字符串，A和B

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f[i][j] = **A前i个字符A[0...i - 1]和B前j个字符[0...j - 1]的最长公共子串的长度**

#### 最后一步
* 观察A[m - 1]和B[n - 1]这两个字符是否作为一个对子在最优策略中
    * 可能A[m - 1]与B[n - 1]的前面的字符即B[0...n - 2]匹配
    * 可能B[n - 1]与A[m - 1]的前面的字符即A[0...m - 2]匹配
    * 可能A[m - 1]与B[n - 1]匹配

#### 子问题
* A[0...m - 1]和B[0...n - 2]**的最长公共子字符串**，A[0...m - 2]和B[0...n - 1]**的最长公共子字符串**和A[0...m - 2]和B[0...n - 2]**的最长公共子字符串**
* A[0...m - 1]和B[0...n - 1]**的最长公共子字符串**

2. 转移方程
* f[i][j] = max{f[i - 1][j], f[i][j - 1], f[i - 1][j - 1] + 1 when A[i - 1] = B[j - 1]}
    * f[i][j] = **A前i个字符A[0...i - 1]和B前j个字符[0...j - 1]的最长公共子串的长度**
    * f[i - 1][j] = **A前i - 1个字符A[0...i - 2]和B前j个字符[0...j - 1]的最长公共子串的长度**
    * f[i][j - 1] = **A前i个字符A[0...i - 1]和B前j - 1个字符[0...j - 2]的最长公共子串的长度**
    * f[i - 1][j - 1] = **A前i个字符A[0...i - 2]和B前j - 1个字符[0...j - 2]的最长公共子串的长度 + 1**

3. 初始条件和边界情况
* 初始条件
    * 空字符串和任何字符串的最长公共子串长度是0
    * f[0][j] = 0, f[i][0] = 0

4. 计算顺序
* 从上到下（行），从左到右（列），由于每个结果都存在了数组中，就能解决重复计算
    1. 计算第一行：f[0][0] = 0, f[0][1] = 0, ..., f[0][n] = 0
    2. 计算第二行：f[1][0], f[1][1], ..., f[1][n]
    <br>...<br>
    3. 计算第m行：f[m][0], f[m][1], ..., f[m][n]
* 当我们计算到f[i][j]时，f[0][0]，f[0][1]，f[1][0]，...，f[i - 1][j - 1]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 到达每个格子的方式都要计算，并都使用前面的结果计算
    * 总时间复杂度 = O(m * n)

### 答案
```java
public int longestCommonSubsequence(String text1, String text2) {

    char[] A = text1.toCharArray();
    char[] B = text2.toCharArray();

    int m = A.length;
    int n = B.length;

    int[][] f = new int[m + 1][n + 1];

    // 遍历每个格子
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            // 初始条件
            if (i == 0 || j == 0) {
                continue;
            }
            f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);
            if (A[i - 1] == B[j - 1]) {
                f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);
            }
        }
    }

    return f[m][n];
}
```

### 复杂度
* 时间复杂度：O(n * m)
* 空间复杂度：O(n * m)
