### 题目
https://leetcode.com/problems/add-binary/

### 分类
* [位运算](https://zhuanlan.zhihu.com/p/26890617)
* 序列型动态规划

### 答案
```
public int[] countBits(int n) {
    int[] results = new int[n + 1];
    for (int i = 0; i <= n; i++) {
        results[i] = Integer.bitCount(i);
    }
    return results;
}
```

### 复杂度
* 时间复杂度：O(n)
* 空间复杂度：O(n)

### 思路2
* 序列型动态规划
```
每一个2的整数幂的二进制表示中都只有一个"1"
每一个非2的整数幂的二进制表示中"1"的个数都可以这样计算：
该数减去比它小的最大的2的整数幂，那么得到的数的二进制表示中"1"的个数再加上1就是该数的二进制表示中"1"的个数
例如5：(101)
比5小的最大的2的整数幂 = 2^2 = 4 (100)
5 - 4 = 1 (01)
1的二进制表示中"1"的个数 = 1
1 + 1 = 2

例如6：(110)
比6小的最大的2的整数幂 = 2^2 = 4 (100)
6 - 4 = 2 (10)
2的二进制表示中"1"的个数 = 1
1 + 1 = 2

例如7：(111)
比7小的最大的2的整数幂 = 2^2 = 4 (100)
7 - 4 = 3 (11)
3的二进制表示中"1"的个数 = 2
1 + 2 = 3
```

### 答案
```
public int[] countBits(int n) {
    int[] f = new int[n + 1];
    f[0] = 0;
    int max = 1; // 记录比i小的最大的2的整数幂
    for (int i = 1; i <= n; i++) {
        if (i < max * 2) {
            f[i] = f[i - max] + 1;
        } else if (i == max * 2) {
            f[i] = 1;
            max = max * 2;
        }
        
    }
    return f;
}
```

### 复杂度
* 时间复杂度：O(n)
* 空间复杂度：O(n)

### 思路3
* 序列型动态规划
```
类似思路2，该数减去比它小的最大的2的整数幂，得到的数的二进制表示中"1"的个数再加上1就是该数的二进制表示中"1"的个数
&与运算可以实现：i&(i-1)，i&(i-1)去除n的位级表示中最低的那一位1
1110 & 1101 = 1100
1110010 & 1110001 = 1110000
1110010101111 & 1110010101110 = 1110010101110
```

### 答案
```
public int[] countBits(int n) {
    int[] f = new int[num + 1];
    for(int i = 1; i <= num; i++){
        f[i] = f[i&(i-1)] + 1;
    }
    return f;
}
```

### 复杂度
* 时间复杂度：O(n)
* 空间复杂度：O(n)
