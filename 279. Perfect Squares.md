### 题目
https://leetcode.com/problems/perfect-squares/

### 分类
动态规划

### 题目特点
求最大最小值：**最少**可以将n分成几个完全平方数（1，4，9...）之和 [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)

### 思路1
0. 输入n

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f[x] = x**最少被分成几个完全平方数之和**

#### 最后一步
* 关注最优策略中最后一个完全平方数j2
* 最优策略中n - j^2也一定被划分成最少的完全平方数之和

#### 子问题
* n - j^2**最少被分成几个完全平方数之和**
* 原问题是n**最少被分成几个完全平方数之和**
* 我们将原问题转化成了一个子问题，而且规模更小：n - j^2

2. 转移方程
* f[x] = min1 <= j^2 <= x {f[x - j^2] + 1}
    * f[x] = x**最少被分成几个完全平方数之和**
    * j^2的取值范围：1 <= j^2 <= x
    * f[x - j^2] = x - j^2**最少被分成几个完全平方数之和**

3. 初始条件和边界情况
* 初始条件
    * f[0] = 0
* 边界情况
    * 注意任何正整数都可以被表示成n个完全平方数的和，例如 3 = 1^2 + 1^2 + 1^2;
    * 无

4. 计算顺序
* x**最少被分成几个完全平方数之和**：f[x] = min1 <= j^2 <= x {f[x - j^2] + 1}
* 初始条件：f[0] = 0
* 然后计算f[1]，f[2]，...，f[n]，这里按照从小到大的顺序，由于每个结果都存在了数组中，就能解决重复计算
* 当我们计算到f[x]时，f[1]，f[2]，...，f[x - 1]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 每一步都遍历j个数字，同时j <= √n，查找数字x - j^2使得f[x - j^2] + 1**最小**，f[n]即一共计算了O(n√n)步
    * 这里需要关注一个重点是任何正整数都可以被表示成n个完全平方数的和，意味着例如f[11] = f[11 - 1] + 1 = f[10] + 1，即最坏的情况下当前数字依然可以由前一个数字 + 1得到
    * 总时间复杂度 = O(n√n)

### 答案1
```
public int numSquares(int n) {
    int[] f = new int[n + 1];
    f[0] = 0; // 初始条件
    // 遍历每一个正整数，i为1...n
    for (int i = 1; i <= n; i++) {
        f[i] = Integer.MAX_VALUE;
        // 每一步都遍历j个数字，同时j <= √i
        // 注意任何正整数都可以被表示成完全平方数的和
        // 因此这个遍历绝对可以找到当前数字最少的完全平方数之和
        for (int j = 1; j * j <= i; j++) {
            if (f[i - j * j] + 1 < f[i]) {
                f[i]  = f[i - j * j] + 1;
            }
        }
    }
    return f[n];
}
```

### 复杂度
* 时间复杂度：O(n^2)
* 空间复杂度：O(n)
