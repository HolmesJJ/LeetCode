### 题目
https://leetcode.com/problems/hamming-distance/

### 分类
* [位运算](https://zhuanlan.zhihu.com/p/26890617)

### 思路1
* 直接使用`Integer.bitCount`

### 答案
```
public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
}
```

### 复杂度
* 时间复杂度：O(1)
* 空间复杂度：O(1)

### 思路2
* 对两个数进行异或操作，位级表示不同的那一位为1，统计有多少个1即可
```
A = 001010
B = 101100
A ^ B = 100110
```
* 算术右移是带符号的右移，逻辑右移是不带符号的右移
    * 算术右移`A >> B`：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数
        * 二进制的第一位代表符号位，1代表"-"，0代表"+"
    * 逻辑右移`A >>> B`：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0
```
A = 11111111111111111111111110000001
B = 2
A >> B = 11111111111111111111111111100000
A >>> B = 00111111111111111111111111100000
```

### 答案
```
public int hammingDistance(int x, int y) {
    // 对两个数进行异或操作，位级表示不同的那一位为1，统计有多少个1即可
    int z = x ^ y;
    int count = 0;
    // z = 0代表无1
    while (z != 0) {
        if ((z & 1) == 1) {
            count++;
        }
        // 右移操作
        // z >>> 1和z >> 1都可以，因为x和y都是大于等于0
        z = z >>> 1;
    }
    return count;
}
```

### 复杂度
* 时间复杂度：O(logn) C是元素的数据范围，在本题中logn = log2^(31) = 31
* 空间复杂度：O(1)
