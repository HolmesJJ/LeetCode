### 题目
https://leetcode.com/problems/unique-paths-ii/

### 分类
* 坐标型动态规划

### 题目特点
计数：**有多少种**方式走到右下角 [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)

### 思路1
0. 输入int[][]的网格数组，有m行n列，其中元素0代表无障碍物，元素1代表有障碍物

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f[i][j] = **机器人有多少种方式从左上角走到**(i, j)

#### 最后一步
* 无论机器人用何种方式到达右下角，总有最后挪动的一步：向右或者向下
* 右下角坐标设为(m - 1, n - 1)
* 那么前一步机器人一定是在(m - 2, n - 1)或(m - 1, n - 2)

#### 子问题
* **机器人有多少种方式从左上角走到**(m - 2，n - 1)和(m - 1，n - 2)
* 原问题是**机器人有多少种方式从左上角走到右下角**(m - 1，n - 1)
* 我们将原问题转化成了一个子问题，而且规模更小：(m - 2，n - 1)和(m - 1，n - 2)

2. 转移方程
* 对于任意一个格子(i, j)，f[i][j] = f[i - 1][j] + f[i][j - 1]
    * **f[i][j] = 机器人有多少种方式从左上角走到**(i, j)
    * **f[i - 1][j] = 机器人有多少种方式从左上角走到**(i - 1, j)
    * **f[i][j - 1] = 机器人有多少种方式从左上角走到**(i, j - 1)

3. 初始条件和边界情况
* 初始条件
    * f[0][0] = 1，因为机器人只有一种方式到左上角
* 边界情况
    * i = 0 或 j = 0，则前一步只能有一个方向过来，即f[i][j] = 1
    * 若左上角[0][0]是障碍，或右下角[m - 1][n - 1]是障碍，输出0种方式
    * 如果[i][j]是障碍，f[i][j] = 0，表示机器人不能到达此格，0种方式

4. 计算顺序
* 从上到下（行），从左到右（列），由于每个结果都存在了数组中，就能解决重复计算
    1. f[0][0] = 1
    2. 计算第0行：f[0][0]，f[0][1]，...，f[0][n - 1]
    3. 计算第1行：f[1][0]，f[1][1]，...，f[1][n - 1]
    <br>...<br>
    4. 计算第m - 1行：f[m - 1][0]，f[m - 1][1]，...，f[m - 1][n - 1]
* 当我们计算到f[i][j]时，f[0][0]，f[0][1]，f[1][0]，...，f[i - 1][j - 1]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 到达每个格子的方式都要计算，并都使用前面的结果计算
    * 总时间复杂度 = O(m * n)

### 答案
```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    if (m == 0) {
        return 0;
    }
    int n = obstacleGrid[0].length;
    if (n == 0) {
        return 0;
    }
    int[][] f = new int[m][n];
    // 第一个格有障碍物
    if (obstacleGrid[0][0] == 1) {
        return 0;
    }
    // 遍历每个格子
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // 有障碍物
            if (obstacleGrid[i][j] == 1) {
                f[i][j] = 0;
            } else {
                // 边界情况
                if (i == 0 && j == 0) {
                    f[i][j] = 1;
                } 
                // 若 i == 0 或 j == 0 时出现障碍物，则障碍物后面的位置都不可能到达
                else if (i == 0 && j - 1 >= 0) {
                    f[i][j] = f[i][j - 1];
                } else if (j == 0 && i - 1 >= 0) {
                    f[i][j] = f[i - 1][j];
                } else {
                    f[i][j] = f[i - 1][j] + f[i][j - 1];
                }
            }
        }
    }
    return f[m - 1][n - 1];
}
```

### 复杂度
* 时间复杂度：O(m * n)
* 空间复杂度：O(m * n)
