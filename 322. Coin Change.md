### 题目
https://leetcode.com/problems/coin-change/

### 分类
* 序列型动态规划

### 题目特点
求最大最小值：如何用**最少**的硬币组合正好付清，不需要对方找钱 [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)

### 思路1
0. 输入coins = [a, b, ..., m]，amount = n

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f(x) = **最少用多少个硬币可以拼出**x
        * **f(x) = min{f(x - a) + 1, f(x - b) + 1, ..., f(x - m) + 1}**

#### 最后一步
1. 虽然我们不知道最优策略是什么，但是最优策略肯定是K枚硬币a1，a2，...，ak面值加起来是最终结果n
2. 所以一定有一枚最后的硬币：ak
3. 除掉这枚硬币，前面k - 1个硬币的面值加起来是：n - ak
* 关键点
    * 我们不关心前面的K - 1个硬币是怎么拼出n - ak的（可能有1种拼法，可能有100种拼法），而且我们现在甚至还不知道ak和K，但是我们确定前面的硬币拼出了n - ak
    * 因为是最优策略，所以拼出n - ak的硬币数一定要最少，否则这就不是最优策略了

#### 子问题
* **最少用多少个硬币可以拼出**n - ak
* 原问题是**最少用多少个可以硬币拼出**n
* 我们将原问题转化成了一个子问题，而且规模更小：n - ak

#### 举例分析
假设输入coins = [2, 5, 7]，amount = 27，那么最后那个硬币只可能是2，5，7
* 如果ak是2，f(27)应该是f(27 - 2) + 1（加上最后这一枚硬币2）
* 如果ak是5，f(27)应该是f(27 - 5) + 1（加上最后这一枚硬币5）
* 如果ak是7，f(27)应该是f(27 - 7) + 1（加上最后这一枚硬币7） 
* 需要求最少的硬币数，所以：f(27) = min{f(27 - 2) + 1, f(27 - 5) + 1,f(27 - 7) + 1}
* 递归解法（存在问题：大量的重复计算，效率极低）
```
int f(int x) {                              // f(X) = 最少用多少个硬币可以拼出X 
    if (x == 0) {                           // 终止条件：0元钱只要0个硬币
        return 0;
    }
    int res = MAX_VALUE;                    // 初始化用无穷大
    if (x >= 2) {                           // 最后一个硬币是2元
        res = Math.min(f(x - 2) + 1, res);
    }
    if (x >= 5) {                           // 最后一个硬币是5元
        res = Math.min(f(x - 5) + 1, res);
    } 
    if (x >= 7) {                           // 最后一个硬币是7元
        res = Math.min(f(x - 7) + 1, res);
    }
    return res;
}
```

2. 转移方程
* 把上面的状态方程中的()换成[]，即**数组**
    * 设状态f[x] = **最少用多少个硬币可以拼出**x
    * **f[x] = min{f[x - a] + 1, f[x - b] + 1, ..., f[x - m] + 1}**
    * x的取值范围为负无穷 - n，[x < 0]设置为正无穷，因此这个数组的实际区间为0 - n，即需要开启n + 1长度的数组

3. 初始条件和边界情况
* 初始条件
    * f[0] = 0，0元钱只要0个硬币
* 边界情况：x - a，x - b，...，x - m小于0怎么办？什么时候停下来？
    * 如果不能拼出y，就定义f[y] = 正无穷
    * 例如f[-1] = f[-2] = 正无穷
    * 所以f[1] = min{f[-1] + 1，f[-4] + 1，f[-6] + 1} = 正无穷，表示拼不出来1

4. 计算顺序
* 拼出x所需要的最少硬币数：**f[x] = min{f[x - a] + 1, f[x - b] + 1, ..., f[x - m] + 1}** 
* 初始条件：f[0] = 0
* 然后计算f[1]，f[2]，...，f[n]，这里按照从小到大的顺序，由于每个结果都存在了数组中，就能解决重复计算
* 当我们计算到f[x]时，f[x - a] + 1，f[x - b] + 1，...，f[x - m]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 每一步都尝试不同的硬币，即coins.length，并都使用前面的结果计算，f[n]即一共计算了n步
    * 总时间复杂度 = n * coins.length

### 答案
```
public int coinChange(int[] coins, int amount) {
    int n = amount;
    int[] f = new int[n + 1]; // 0...n
    f[0] = 0; // 初始条件
    // 遍历每一个需要拼出的值，i为1...n
    for (int i = 1; i <= n; i++) {
        f[i] = Integer.MAX_VALUE; // 把数组的值设为最大值，若该值能被拼出来，就替换为拼出该值的硬币数量
        // 选择不同面值的硬币
        for (int j = 0; j < coins.length; j++) {
            // 选择硬币的条件
            // 1. i >= 硬币面值
            // 2. 不可以是拼不出来的f[i - coins[j]] != Integer.MAX_VALUE
            // 3. 若当前值已经能够被硬币拼出，并且是最少的硬币，即拼出该值前的硬币数量f[i - coins[j]] + 1 < 当前值被别的数量的硬币拼出的数量
            // f[x - 硬币面值] + 1 < f[x]
            if (i >= coins[j] && f[i - coins[j]] != Integer.MAX_VALUE && f[i - coins[j]] + 1 < f[i]) {
                f[i] = f[i - coins[j]] + 1;
            }
        }
    }
    // 值拼不出来
    if (f[n] == Integer.MAX_VALUE) {
        return -1;
    } else {
        return f[n];
    }
}
```

### 复杂度
* 时间复杂度：O(amount * coins.length)
* 空间复杂度：O(amount)
