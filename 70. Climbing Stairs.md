### 题目
https://leetcode.com/problems/climbing-stairs/

### 分类
* 序列型动态规划

### 题目特点
计数：有**多少种**方式爬到台阶n [Dynamic Programming](https://github.com/HolmesJJ/CS2040S-Data-Structures-and-Algorithms/wiki/Dynamic-Programming)

### 思路1
0. 输入n

1. 确定状态
    * 简单的说，解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i][j]代表什么
        * 类似于解数学题中，x，y，z代表什么  
    * 确定状态需要两个意识
        * 最后一步
        * 子问题
    * 根据下面的分析
        * 设状态f[x] = **有多少种方式爬到台阶**x

#### 最后一步
* 如果能爬到最后一个台阶n，我们考虑它爬的最后一步
* 这一步是从台阶i过来，i < n
* 这需要两个条件同时满足
    * 可以到达台阶i
    * 最后一步不超过最大距离：n - i <= 2

#### 子问题
* **有多少种方式爬到台阶**i(i < n）
* 原问题是**有多少种方式爬到台阶**n

2. 转移方程
* f[x] = f[i] + f[j] (i + 1 = x AND j + 2 = x);
    * f[x] = **有多少种方式爬到台阶**x
    * f[i] = **有多少种方式爬到台阶**i
    * f[j] = **有多少种方式爬到台阶**j
    * i + 1 = x AND j + 2 = x = 一次只能爬1个或2个台阶

3. 初始条件和边界情况
* 初始条件
    * f[0] = 1
    * f[1] = 1
* 边界情况
    * 无

4. 计算顺序
* 有多少种方式爬到台阶x：f[x] = f[i] + f[j] (i + 1 = x AND j + 2 = x);
* 初始条件：f[0] = 1，f[1] = 1
* 然后计算f[2]，f[3]，...，f[n]，这里按照从小到大的顺序，由于每个结果都存在了数组中，就能解决重复计算
* 当我们计算到f[x]时，f[1]，f[2]，...，f[x]都已经得到结果了
    * 没有重复计算，**解决了重复计算的问题**
    * 每一步可以根据前两步计算得到f[i] = f[i - 1] + f[i - 2]
    * 总时间复杂度 = O(n)

### 答案
```java
public int climbStairs(int n) {
    int[] f = new int[n + 1];
    f[0] = 1;
    f[1] = 1; // 初始条件
    // 遍历每一个正整数，i为1...n
    for (int i = 2; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 2];
    }
    return f[n];
}
```

### 复杂度
* 时间复杂度：O(n)
* 空间复杂度：O(n)
